
/*
-----------------------------------------------------------------------------
This source file is part of OSTIS (Open Semantic Technology for Intelligent Systems)
For the latest info, see http://www.ostis.net

Copyright (c) 2010 OSTIS

OSTIS is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OSTIS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with OSTIS.  If not, see <http://www.gnu.org/licenses/>.
-----------------------------------------------------------------------------
*/

#include "scp_keynodes.scsy"
#include "wave_find_path_keynodes.scsy"

//
// Программа поиска предыдущей вершины для переданной вершины из пути.
// Смотреть "Оператор S20"
// 
// @author Dmitry Lazurkin
//
procedure(find_prev_path_vertex,
[[
	1_, 2_;
]], 
[{
	arc, arc1,            // временные переменные для хранения дуг
	element,              // временная переменная для хранения элемента
	edge_iter_arc,        // для итерации по ребрам
	cur_edge,             // текущее ребро
	vertex1, vertex2,     // вершины, инцидентные ребру
	edges,                // множество ребер графа
	graph, waves_list, last_wave, cur_path_vertex, prev_wave, path_edge, prev_path_vertex // параметры процедуры
}], 
{[
	1_:  in_: graph,           // _Gi
	2_:  in_: waves_list,      // _список волн
	3_:  in_: last_wave,       // _последняя волна
	4_:  in_: cur_path_vertex, // _n1
	5_: out_: prev_wave,       // _предыдущая волна
	6_: out_: path_edge,       // _edge
	7_: out_: prev_path_vertex // _n2
]})

// Ищем связку, в которую входит последняя волна.
// если связка не найдена, значит достигнуто начало списка 
searchElStr5([
	1_: assign_: element,
	2_: assign_: arc,
	3_:  fixed_: last_wave,
	4_: assign_: arc1,
	5_:  fixed_: 2_
],, first_wave_in_list)

// Ищем первый элемент для найденной связки, т.е. предыдущую волну
searchElStr5([
	1_:  fixed_: element,
	2_: assign_: arc,
	3_: assign_: prev_wave,
	4_: assign_: arc1,
	5_:  fixed_: 1_
])

// Формируем множество ребер графа
searchSetStr5([
    1_:  fixed_: graph,
    2_: assign_: const_: pos_: arc,
    3_: assign_: element,
	4_: assign_: const_: pos_: arc1,
	5_:  fixed_: edge_,
    set3_: assign_: edges
])

label(iter_edge_next)
	// Производим итерацию по ребрам
	searchElStr3([
	    1_:  fixed_: edges,
	    2_: assign_: edge_iter_arc,
	    3_: assign_: cur_edge
	],, iter_edge_end)
	
	// Проверяем инцидентность cur_path_vertex ребру, 
	// выбранному на текущей итерации
	searchElStr3([
	    1_:  fixed_: cur_edge,
	    2_: assign_: arc,
	    3_:  fixed_: cur_path_vertex
	],, iter_edge_erase_arc)
	
	// Получаем, отличную от найденной, вершину, инцидентную ребру cur_edge
	callReturn([
		1_: fixed_: get_second_edge_vertex, 
		2_: {[
			1_: cur_edge,
			2_: cur_path_vertex,
			3_: vertex2
		]}
	])
	
	// Проверяем vertex2 на вхождение в предыдущую волну
	searchElStr3([
	    1_:  fixed_: prev_wave,
	    2_: assign_: arc,
	    3_:  fixed_: vertex2
	], vertex2_in_last_wave)

	label(iter_edge_erase_arc)
	// Удаляем текущее ребро из множества всех ребер
	eraseEl([1_: fixed_: f_: edge_iter_arc], iter_edge_next, iter_edge_next)
		
label(vertex2_in_last_wave)
// Необходимая вершина найдена, устанавливаем выходные параметры
varAssign([1_: prev_path_vertex, 2_: fixed_: vertex2])
varAssign([1_: path_edge, 2_: fixed_: cur_edge])

label(iter_edge_end)

// Удаляем из памяти множество ребер
eraseEl([1_: fixed_: f_: edges])

label(first_wave_in_list)
return()

end
