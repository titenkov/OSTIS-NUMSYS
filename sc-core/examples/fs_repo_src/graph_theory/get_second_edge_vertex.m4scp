/*
-----------------------------------------------------------------------------
This source file is part of OSTIS (Open Semantic Technology for Intelligent Systems)
For the latest info, see http://www.ostis.net

Copyright (c) 2010 OSTIS

OSTIS is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OSTIS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with OSTIS.  If not, see <http://www.gnu.org/licenses/>.
-----------------------------------------------------------------------------
*/

#include "scp_keynodes.scsy"

//
// Процедура получения вершины, инцидентной ребру.
// Учитывает кратное вхождение вершин, т.е. петлю.
//
// @author Dmitry Lazurkin
//
procedure(get_second_edge_vertex,
[[
]], 
[{
	arc,                   // временная переменная для хранения дуги
	element,               // временная переменная для хранения узла
	edge_copy,             // копия ребра
	edge, vertex1, vertex2 // параметры процедуры
}], 
{[
	1_:  in_: edge,          // ребро
	2_:  in_: vertex1,       // первая вершина
	3_: out_: vertex2        // вторая вершина
]})

///////////////////////////////////////////////////////
// создаем копию множества вершин, инцидентных ребру
searchSetStr3([
    1_:  fixed_: edge,
    2_: assign_: const_: pos_: arc,
    3_: assign_: element,
    set3_: assign_: edge_copy
])

///////////////////////////////////////////////////////
// ищем в множестве вершин, инцидентных ребру, дугу, связывающее первую вершину с ребром графа 
searchElStr3([
    1_:  fixed_: edge_copy,
    2_: assign_: arc,
    3_:  fixed_: vertex1
],, return_label)

///////////////////////////////////////////////////////
// удаляем из множества вершин, инцидентных ребру, первую вершину
eraseEl([1_: arc])

///////////////////////////////////////////////////////
// ищем в копии множества вершин, инцидентных ребру, оставшуюся вершину, и считаем ее за вторую
searchElStr3([
    1_:  fixed_: edge_copy,
    2_: assign_: arc,
    3_: assign_: vertex2
])

///////////////////////////////////////////////////////
// очищаем память от копии множества вершин, инцидентных ребру
eraseEl([1_: edge_copy])

label(return_label)
return()

end
